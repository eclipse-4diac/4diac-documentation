---
title: "Modbus"
url: doc/communication/modbus.html
---

= Modbus
:lang: en
:imagesdir: img

== Installation Instructions

The Modbus com interface need the http://libmodbus.org/[libmodbus] library to work. 
Follow the steps below to set up your environment before compiling 4diac FORTE.

. libmodbus files should be placed in the following folder structure:
* `[libmodbushome]/include/modbus`: include files
* `[libmodbushome]/lib`: `libmodbus.lib` (windows) or `libmodbus.so` (posix)
. When configuring 4diac FORTE project with CMake choose `[libmodbushome]` as `FORTE_COM_MODBUS_LIB_DIR`
. `forte.exe` must be able to find the dynamic libmodbus library after build. 
 Therefore copy `libmodbus.dll/so` to folder with `forte.exe` or add `libmodbus.dll/so` to library include path.

== Parameters

=== Modbus Client (TCP)

Usage of the Modbus Client (TCP):
----
modbus[(protocol:)ip:port:(slaveId):pollFrequency:readAddresses:sendAddresses(:responseTimeout:byteTimeout)]
----

* *protocol*: tcp (tcp is default)
* *ip*: address of Modbus server, e.g. 127.0.0.1
* *port*: preferably above 1024, default is 502
* *slaveId* (optional): The unit identifier (Slave ID). While often ignored in pure Modbus TCP, it is **mandatory** in the following cases:
** Connection to a Modbus-RTU to Modbus-TCP Gateway (e.g., EX9133C-2-MTCP): The Slave ID determines which device on the serial line is addressed.
** Specific devices (e.g., Siemens SENTRON PAC power meters) require a specific Slave ID (standard is 0xFF or 1) to accept the connection.
** The factory default for many devices is 1.
* *pollFrequency*: polling frequency in milliseconds.
* *readAddresses*: addresses can be specified between 0-65535. More than one address (max 100) can be specified. **Note on Efficiency:** Using ranges (e.g., `h51` as a bitmask for 16 inputs) is much faster than polling 16 individual coils.
** comma for separate addresses: `0,2,65500`
** dots for interval: `5..10`
** combination: `0,5..10,2,65500`
** function is by default holding register, and can be changed with a prefixed letter:
*** 'c' for coil (Read/Write bits)
*** 'd' for discrete input (Read-only bits)
*** 'h' for holding register (Read/Write 16-bit words)
*** 'i' for input register (Read-only 16-bit words)
*** --> see below for a Detailed Table
* *sendAddresses*: addresses can be specified between 0-65535 if data is only read sendAddresses should be left empty more than one address (max 100) can be specified using
** comma for separate addresses 0,2,65500
** dots for interval 5..10
** combination 0,5..10,2,65500
** function can be selected like for readAddresses
* *responseTimeout* (optional): timeout in milliseconds to wait for a response (500ms is default)
* *byteTimeout* (optional): timeout in milliseconds between two consecutive bytes (500ms is default)
* to reuse a previous connection define only ip and port and leave everything up to slaveId empty

Example:
----
modbus[tcp:127.0.0.1:502::20000:h0..3:]
----

=== Modbus Client (RTU)

Usage of the Modbus Client (RTU):
----
modbus[protocol:port:baudrate:parity:databits:stopbits:flow:(slaveId):pollFrequency:readAddresses:sendAddresses(:responseTimeout:byteTimeout)]
----

* *protocol*: rtu
* *port*: serial port, e.g., /dev/ttyS0 or COM1
* *baudrate*: serial port baudrate, e.g., 9600
* *parity*: N for none, E for even, O for odd
* *databits*: number of data bits, e.g., 8
* *stopbits*: number of stop bits, e.g., 1
* *flow*:
** leave empty for none
** arduino - disables DTR and waits for the Arduino to boot (useful for direct USB connection to Arduino-based IO).
** delay - waits 2 seconds after connecting. This is often necessary for RS485-to-USB converters or devices that need time to stabilize the serial line after the port is opened.
** longdelay - waits 3 seconds after connecting.
* all other parameters are the same as for TCP.
** except the *slaveId*, which is **mandatory** for Modbus-RTU. The factory default for most devices is 1.
* to reuse a previous connection define only port and leave everything up to slaveId empty

Example:
----
modbus[rtu:/dev/ttyUSB0:19200:N:8:1::1:2000:i6142,i6132,i6137:h64025..64028,h63995..63998]
----

== Table of Functions and FB Configuration

The choice of the Modbus function (Parameter prefix `c`, `d`, `h`, `i`) dictates which IEC 61499 Function Block (FB) and which Data Types you **must** use. Using the wrong combination will lead to communication errors or misaligned data.

=== Internal Data Mapping
Understanding how 4diac FORTE maps IEC data types to Modbus calls is crucial:

* **Coils (`c`) and Discrete Inputs (`d`)**:
** Internally, `libmodbus` expects **1 Byte per Bit**.
** Therefore, for every single coil/input address defined in the string (e.g., `c0`), you need **one** corresponding input/output on the FB.
** **Correct Types:** `BOOL` (recommended), `BYTE`, `SINT`, `USINT`. All these take up 1 Byte internally and map to 1 Modbus Bit.
** **Example:** Reading `c0..7` (8 Bits) requires a `CLIENT_8` FB with 8 `BOOL` outputs.

* **Holding (`h`) and Input Registers (`i`)**:
** Internally, these are **16-Bit Words** (2 Bytes).
** **Correct Types:** `WORD`, `INT`, `UINT` map exactly to 1 Register.
** **32-Bit Types:** `DWORD`, `DINT`, `UDINT`, `REAL` map to **2 Registers**.
** **64-Bit Types:** `LWORD`, `LINT`, `ULINT`, `LREAL` map to **4 Registers**.
** **Example 1:** Reading `h10` (1 Register) requires a `CLIENT_1` FB with 1 `WORD` output.
** **Example 2:** Reading `h10..11` (2 Registers) could use:
*** A `CLIENT_2` FB with 2 `WORD` outputs.
*** OR a `CLIENT_1` FB with 1 `DWORD` output (interpreting the 2 registers as one 32-bit value).

=== detailed Configuration Table

[cols="1,1,1,1,3", options="header"]
|===
| Prefix | Modbus Type | Data Size | Recommended IEC Types | FB Selection Rule

| **c**
| Coil (Read/Write)
| 1 Bit
| `BOOL`
| **1 FB-Pin per Address.** +
For `c0..7` (8 addresses), use `CLIENT_8` with `BOOL` pins.

| **d**
| Discrete Input (Read Only)
| 1 Bit
| `BOOL`
| **1 FB-Pin per Address.** +
For `d0` (1 address), use `CLIENT_1` with `BOOL` pin.

| **h**
| Holding Register (Read/Write)
| 16 Bit
| `WORD`, `INT`, `UINT`
| **1 FB-Pin per Address (for 16-bit types).** +
For `h40001` (1 address), use `CLIENT_1` with `WORD`. +
For 32-bit types (`REAL`, `DWORD`), 1 Pin covers 2 Addresses.

| **i**
| Input Register (Read Only)
| 16 Bit
| `WORD`, `INT`, `UINT`
| Same as Holding Register.
|===

=== Examples for common Scenarios

#### Scenario A: Reading 8 Switches (Discrete Inputs)
* **Hardware:** 8 Digital Inputs at Modbus addresses 0 to 7.
* **String:** `modbus[tcp:192.168.1.10:502::1000:d0..7:]`
* **FB:** `CLIENT_8` (from `modbus` library or generic `CLIENT_8`).
* **Configuration:** Set all 8 Outputs (`RD_1` to `RD_8`) to type `BOOL`.

#### Scenario B: Controlling 8 Relais (Coils)
* **Hardware:** 8 Relais at addresses 0 to 7.
* **String:** `modbus[rtu:/dev/ttyUSB0:9600:N:8:1::1:1000:c0..7:c0..7]`
* **FB:** `CLIENT_8`.
* **Configuration:** Set all 8 Inputs (`SD_1` to `SD_8`) and Outputs (`RD_1` to `RD_8`) to type `BOOL`.

#### Scenario C: Reading a Temperature (Float, 32-bit)
* **Hardware:** Sensor maps float value to Registers 10 and 11.
* **String:** `modbus[tcp:192.168.1.20:502::500:h10..11:]`
* **FB:** `CLIENT_1`.
* **Configuration:** Set `RD_1` to type `REAL`. The FB automatically reads 2 registers (10 and 11) and combines them into one Float.

#### Scenario D: AkYtec / Bitmasks (Holding Register)
* **Hardware:** Input states are packed into one 16-Bit Register (Bitmask) at Address 51.
* **String:** `modbus[tcp:192.168.1.99:502::500:h51:]`
* **FB:** `CLIENT_1`.
* **Configuration:** Set `RD_1` to type `WORD`. You will receive an Integer (e.g., 5 means Input 1 and 3 are active). Use `WORD_TO_BOOL` conversion FBs to extract individual bits if needed.



== Where to go from here?

* Go back to Protocols index: +
xref:./communication.adoc[Communication Index]
* If you want to go back to the Start Here page, we leave you here a fast access +
xref:../doc_overview.adoc[Start Here page]

Or link:#top[Go to top]
